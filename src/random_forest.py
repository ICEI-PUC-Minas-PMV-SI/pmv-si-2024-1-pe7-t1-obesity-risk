# -*- coding: utf-8 -*-
"""Random_Forest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qvmX27J90dXlCOJytA2S5aAOiALYNfHM
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import cross_val_score




# CONEXÃO COM GOOGLE DRIVE
from google.colab import drive
drive.mount('/content/drive/')

# DEFININDO A VARIAVEL QUE IRÁ LER O DATAFRAME
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/ObesityDataSet.csv')


# Converter valores de string em valores numéricos usando LabelEncoder
label_encoder = LabelEncoder()
df_encoded = df.apply(label_encoder.fit_transform)

# Definir as variáveis preditoras (features)
X = df_encoded.drop("NObeyesdad", axis=1)  # Remove a coluna "grau de obesidade"

# Definir a variável alvo (target)
y = df_encoded["NObeyesdad"]

# Dividir os dados em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Criar o modelo Random Forest
rf_model = RandomForestClassifier(max_depth=10, n_estimators=100, random_state=42)

# Treinar o modelo com os dados de treinamento
rf_model.fit(X_train, y_train)

# Fazer previsões com os dados de teste
y_pred = rf_model.predict(X_test)

# Calcular a acurácia do modelo
accuracy = accuracy_score(y_test, y_pred)
print("Acurácia do modelo Random Forest:", accuracy)

# Imprimir a importância das características
feature_importances = rf_model.feature_importances_
print("\nImportância das características:")
for feature, importance in zip(X.columns, feature_importances):
    print(f"{feature}: {importance:.4f}")

# Imprimir a matriz de confusão
conf_matrix = confusion_matrix(y_test, y_pred)
print("\nMatriz de Confusão:")
print(conf_matrix)

# Relatório de classificação
print('\nRelatório de classificação no conjunto de teste:')
print(classification_report(y_test, y_pred))


# Treinar e avaliar o modelo usando validação cruzada
scores = cross_val_score(rf_model, X, y, cv=5)  # 5-fold cross-validation
print(f"Acurácias nas diferentes dobras: {scores}")
print(f"Acurácia média: {np.mean(scores)}")

col_name = "NObeyesdad"  # Substitua 'nome_da_coluna' pelo nome da coluna desejada

# Criar um vetor vazio
vetor = []
vetorx = []

# Adicionar os elementos do conjunto de dados ao vetor
for value in df_encoded[col_name]:
    vetor.append(value)

for val in df[col_name]:
    vetorx.append(val)

# Associar os elementos dos dois vetores em pares de tuplas
pares_associados = zip(vetor, vetorx)

# Imprimir os pares associados
for par in pares_associados:
    print(par)